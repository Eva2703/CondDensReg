% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mixed_density_smooth.R
\name{smooth.construct.md.smooth.spec}
\alias{smooth.construct.md.smooth.spec}
\title{P-Splines with integrate-to-zero constraint for density regression}
\usage{
\method{smooth.construct}{md.smooth.spec}(object, data, knots)
}
\arguments{
\item{object}{a smooth specification object, usually generated by a term
\code{ti(x, bs="md", ...)}}

\item{data}{a list containing just the data (including any \code{by} variable) required by this term, 
            with names corresponding to \code{object$term} (and \code{object$by}). The \code{by} variable 
            is the last element.}

\item{knots}{a list containing any knots supplied for basis setup --- in same order and with same names as \code{data}. 
             Can be \code{NULL}. See details for further information.}
}
\value{
An object of class \code{"mdspline.smooth"}. See
\code{\link[mgcv]{smooth.construct}}, for the elements that this object will contain.
}
\description{
Specifying \code{bs = "md"} in the tensor product smooth \code{\link[mgcv]{ti}}
(setting \code{mc = FALSE}) constructs a smoother to be used in \code{mgcv}'s
\code{\link[mgcv]{gam}} with \code{family = poisson()} for the case that the
response variable of interest is a density in a mixed Bayes Hilbert space
\eqn{B^2(\mu) = B^2(\mathcal{Y}, \mathcal{A}, \mu)}{B^2(\mu) = B^2(Y, A, \mu)}
(including continuous or discrete ones as special cases) as in Maier et al. (2025b).
The subset of the domain \eqn{\mathcal{Y}}{Y} corresponding to the continuous
part of the densities is denoted with \eqn{I}, the one corresponding to the
discrete part with \eqn{\mathcal{D}}{D}.
Corresponding covariate observations are the discrete values for the discrete
component and the midpoints of the bins underlying the histograms approximating
the densities for the continuous component. Response observations are the
counts of the discrete observations and the histograms (the count data can
easily be constructed from individual data with \code{\link{data2counts}}).
Specification of basis and penalization details for the continuous component
is as for \code{bs = "ps"}, see \code{mgcv}'s
\code{\link[mgcv]{smooth.construct.ps.smooth.spec}}, which our implementation
is oriented on.
Specification of the domain and for the discrete component is possible via
the argument \code{xt} in \code{\link[mgcv]{ti}} (see below). % \cr % Linebreak

Note that the implementation includes the integrate-to-zero constraint of
\eqn{L^2_0}, i.e., further centering is not reasonable! This means, that the
constructor should not be used with \code{\link[mgcv]{s}} or
\code{\link[mgcv]{te}}, which always include centering (sum-to-zero) constraints
for all marginals. Instead, it is supposed to be used with \code{\link[mgcv]{ti}},
setting \code{mc = FALSE} for the corresponding component.
% (It would be desirable to include a warning, however, object does not seem
% to contain information on which kind of function it was called in.)

We recommend to use \code{link{densreg}} to specify density regression models
(based on \code{smooth.construct.md.smooth.spec}), instead of via \code{\link[mgcv]{gam}}
directly, since the is quite cumbersome and specification has to be done with
extreme care to obtain a reasonable model.
}
\details{
The basis and penalty are constructed from a P-spline basis (continuous component)
respectively indicator functions with optional difference penalty (discrete
component) transformed to \eqn{L^2_0} as described in Appendix D of Maier et al.
(2025a) and embedded to the mixed Bayes Hilbert space as described in Section
2.2 of Maier et al. (2025b).
The argument \code{xt} in \code{\link[mgcv]{ti}} is used for further specification
regarding the underlying Bayes Hilbert space. \code{xt} has to be a list of
the same length as the vector \code{bs} specifying the marginal bases. For all
\code{"md"} type marginal bases, the corresponding \code{xt}-list element is
again a list with the following elements:
% ti(..., xt = list(list(values_discrete = NULL,
%                        weights_discrete = NULL,
%                        domain_continuous = NULL,
%                        penalty_discrete = NULL)))
\itemize{
\item
\code{values_discrete}: Vector of values in \eqn{\mathcal{D}}{D} (the subset of
the domain corresponding to the discrete part of the densities). Defaults to
missing (\code{NULL}) in which case it is set to \code{c(0, 1)}. If set to
\code{FALSE}, the discrete component is considered to be empty, i.e., the
Lebesgue measure is used as reference measure (continuous special case).
\item
\code{weights_discrete}: Vector of weights for the Dirac measures corresponding
to \code{values_discrete}. If missing (\code{NULL}) it is set to 1 in all
components as default. Can be a scalar for equal weights for all discrete values
or a vector with specific weights for each corresponding discrete value.
\item
\code{domain_continuous}: An interval (i.e., a vector of length 2) specifying
\eqn{I}. If missing (\code{NULL}) it is set to \code{c(0, 1)} as default. If
set to \code{FALSE}, the continuous component is considered to be empty, i.e.,
a weighted sum of dirac measures is used as reference measure (discrete special
case).
\item
\code{penalty_discrete}: integer (or \code{NULL}) giving the order of
differences to be used for the penalty of the discrete component, with \code{0}
corresponding to the identity matrix as penalty matrix (analogously to \code{m[2]}
for the continuous component); Note that the order of differences must be smaller
than the number of values in the discrete component, i.e., the length of
\code{values_discrete}; if missing (\code{NULL}), in the mixed case, it is
set to a zero matrix (corresponding to no penalization), while in the discrete
case, it is set to a diagonal matrix (as in a ridge penalty). In the discrete
case, please set the corresponding argument of \code{sp} in \code{\link[mgcv]{ti}}
to \code{0} to estimate an unpenalized model.
% For marginal bases of type \code{"ps"}/\code{"bs"}, the corresponding xt-list
% element has to be set to \code{NULL}.
}
}
\examples{
\donttest{
### create data
set.seed(101)

N <- 100
dta <- data.frame(covariate1 = sample(c("a", "b", "c"), N, replace = TRUE),
                  covariate2 = rnorm(n = N))
dta$obs_density <- sapply(seq_len(N),
                          function(i) {
                            a_0 <- ifelse(dta$covariate1[i] == "a", 0.1,
                                          ifelse(dta$covariate1[i] == "b", 0.2, 0.3))
                            p_0 <- a_0 * sin(dta$covariate2[i]) + a_0 + 0.05
                            a_1 <- ifelse(dta$covariate1[i] == "a", 0.25,
                                          ifelse(dta$covariate1[i] == "b", 0.15, 0.05))
                            p_1 <- a_1 * cos(dta$covariate2[i]) + a_1 + 0.1
                            sample(0:2, 1, prob = c(p_0, p_1, 1 - p_0 - p_1))
                          })

dta$covariate1 <- ordered(dta$covariate1)

# data for the mixed case
dta_mixed <- dta
ind_cont <- which(dta_mixed$obs_density == 2)
dta_mixed[ind_cont, ]$obs_density <-
  sapply(seq_along(ind_cont), function(i)
    rbeta(1, shape1 = 1 + exp(dta_mixed$covariate2[i]),
          shape2 = 1 + as.numeric(dta_mixed$covariate1[i])))
n_bins <- 20
dta_mixed <- data2counts(dta = dta_mixed, var_vec = c("covariate1", "covariate2"),
                        bin_number = n_bins, values_discrete = c(0, 1),
                        domain_continuous = c(0, 1))

# data for the continuous case
dta_cont <- dta_mixed[which(!dta_mixed$discrete), ]

# data for the discrete case
dta_dis <- data2counts(dta = dta, c("covariate1", "covariate2"),
                      values_discrete = c(0, 1, 2), domain_continuous = FALSE)

### fit model in the mixed case
# All marginals in density-direction are specified via the mixed density basis "md",
# which per default uses a mixed Bayes Hilbert space with continuous domain (0, 1)
# and discrete values at 0 and 1. Since this is exactly our scenario, we don't
# actually need to specify xt here.

m_mixed <- gam(counts ~
                 # no scalar global intercept (we add a density-intercept instead)
                 - 1 +
                 # intercept (corresponding to reference covariate1 = "a")
                 ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                    mc = FALSE, np = FALSE) +
                 # group specific intercept for leveles "b" and "c" of covariate2
                 ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                    mc = FALSE, np = FALSE, by = covariate1) +
                 # smooth effect of covariate2 (modeled via P-splines)
                 ti(covariate2, obs_density, bs = c("ps", "md"),
                    m = list(c(2, 2), c(2, 2)), k = c(8, 8), mc = c(TRUE, FALSE),
                    np = FALSE) +
                 # intercepts per covariate combination (modeling absolute
                 # counts for poisson regression)
                 as.factor(group_id) +
                 # offsets: log(Delta) accounting for bin width, gam_offsets
                 # for weighted observations
                 offset(log(Delta)),
               family = poisson(), method = "REML", data = dta_mixed)

### fit model in the continuous case
# Continuous domain (0, 1) without discrete values
xt_c <- list(values_discrete = FALSE, domain_continuous = c(0, 1))

m_cont <- gam(counts ~
                # no scalar global intercept (we add a density-intercept instead)
                - 1 +
                # intercept (corresponding to reference covariate1 = "a")
                ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                   mc = FALSE, np = FALSE, xt = list(xt_c)) +
                # group specific intercept for leveles "b" and "c" of covariate2
                ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                   mc = FALSE, np = FALSE, xt = list(xt_c), by = covariate1) +
                # smooth effect of covariate2 (modeled via P-splines)
                ti(covariate2, obs_density, bs = c("ps", "md"), m = list(c(2,2), c(2,2)),
                   k = c(8, 8), mc = c(TRUE, FALSE), np = FALSE,
                   xt = list(NULL, xt_c)) +
                # intercepts per covariate combination (modeling absolute
                # counts for poisson regression)
                as.factor(group_id) +
                # offsets: log(Delta) accounting for bin width, gam_offsets
                # for weighted observations
                offset(log(Delta)),
              family = poisson(), method = "REML", data = dta_cont)

### fit model in the discrete case
# Continuous domain empty, discrete values 0, 1, 2
xt_d <- list(domain_continuous = FALSE, values_discrete = c(0, 1, 2))

m_dis <- gam(counts ~
               # no scalar global intercept (we add a density-intercept instead)
               - 1 +
               # intercept (corresponding to reference covariate1 = "a")
               ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                  mc = FALSE, np = FALSE, xt = list(xt_d), sp = 0) +
               # group specific intercept for leveles "b" and "c" of covariate2
               ti(obs_density, bs = "md", m = list(c(2, 2)), k = 8,
                  mc = FALSE, np = FALSE, xt = list(xt_d), sp = 0, by = covariate1) +
               # smooth effect of covariate2 (modeled via P-splines)
               ti(covariate2, obs_density, bs = c("ps", "md"), m = list(c(2,2), c(2,2)),
                  k = c(8, 8), mc = c(TRUE, FALSE), np = FALSE,
                  xt = list(NULL, xt_d), sp = c(-1, 0)) +
               # intercepts per covariate combination (modeling absolute
               # counts for poisson regression)
               as.factor(group_id) +
               # offsets: log(Delta) accounting for bin width, gam_offsets
               # for weighted observations
               offset(log(Delta)),
             family = poisson(), method = "REML", data = dta_dis)
}

}
\references{
Maier, E.-M., Fottner, A., Stoecker, A., Okhrin, Y., & Greven, S. (2025b):
Conditional density regression for individual-level data.
arXiv preprint arXiv:XXXX.XXXXX.

Maier, E.-M., Stoecker, A., Fitzenberger, B., Greven, S. (2025a):
Additive Density-on-Scalar Regression in Bayes Hilbert Spaces with an Application to Gender Economics.
Annals of Applied Statistics, 19(1), ???-???.
}
\author{
Eva-Maria Maier, Alexander Fottner
}
