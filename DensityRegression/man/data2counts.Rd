% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data2counts.R
\encoding{UTF-8}
\name{data2counts}
\alias{data2counts}
\title{From observations to a vector of observed (histogram) counts}
\usage{
data2counts(
  dta,
  var_vec,
  y = NULL,
  sample_weights = NULL,
  counts = NULL,
  weighted_counts = NULL,
  bin_width = NULL,
  bin_number = NULL,
  values_discrete = c(0, 1),
  weights_discrete = 1,
  domain_continuous = c(0, 1)
)
}
\arguments{
\item{dta}{Data set of type \code{\link[base]{data.frame}} or
\code{\link[data.table]{data.table}} containing the observations \eqn{(y_i, x_i)}
of response and covariates as well as optional sample weights (compare
\code{sample_weights}) for each observation in the rows (\eqn{i = 1, ..., N}).}

\item{var_vec}{Vector of variables of \code{dta} on which the covariate
combinations are based. The vector can either contain the variable names as
strings or the column positions of the respective variables in \code{dta}.}

\item{y}{Variable in \code{dta} containing the response observations
\eqn{y_i}. Either the variable name can be given as string or the column
position of the variable in \code{dta} as integer. If missing (\code{NULL}),
if there is a unique column of \code{dta} not specified in \code{var_vec},
\code{sample_weights}, \code{counts}, and \code{weighted_counts} (see below),
this unique column is used.}

\item{sample_weights}{(Optional) variable in \code{dta} which contains a sample
weight for each observation. Either the variable name can be given as string
or the column position of the variable in \code{dta} as integer. If missing
(\code{NULL}), no sample weights are included per default (i.e., all
observations have the same weight 1).}

\item{counts}{(Optional) variable in \code{dta} which contains a count for
each observation (for cases, where the available data contains counts instead
of individual observations, which is common in particular for discrete data).
Either the variable name can be given as string or the column position of the
variable in \code{dta} as integer. If \code{bin_number} and \code{bin_width}
are both \code{NULL}, midpoints of unique observations \eqn{y_i} are used as
boundaries of histogram bins (if \eqn{I} is not empty, i.e., if there is a
continuous component), which are then used to compute the bin widths (which are
later required es offset in the regression model).
If argument \code{counts} is missing (\code{NULL}; default), counts are
constructed from individual observations (which is equivalent to each observation
counted once). Note that if \code{counts} and \code{sample_weights} are both
not \code{NULL}, the latter is ignored (also indicated via a warning message).
Please use \code{weighted_counts} (additionally to \code{counts}) to include
possible weighted data.}

\item{weighted_counts}{(Optional) variable in \code{dta} which contains a
weighted count for each observation (compare Appendix D of Maier et al. (2025b)).
In this case, also absolute counts have to be specified via \code{counts}.
Otherwise, \code{weighted_counts} is ignored. Either the variable name can be
given as string or the column position of the variable in \code{dta} as integer.
If missing (\code{NULL}), counts are constructed from individual observations
(which is equivalent to all observations counted once)
% @param already_formatted A logical indicating if the data in \code{dta} is
% already formatted as count data. If \code{already_formatted = TRUE}, the data
% have to have a column named \code{"counts"}, an additional column with the
% name \code{"weighted_counts"} is optional.
% % The relevant variables used for further aggregation are submitted via \code{var_vec}, the relevant column of the observed density via \code{y}.
% The bin width is computed automatically based on the observed continuous
% values unless an integer or a vector is submitted by the user via
% \code{bin_width} and/or \code{bin_number}. In these cases, the binning is
% based on the given bin number or width.
.}

\item{bin_width}{Width of histogram bins partitioning \eqn{I}. Can be one
scalar value (specifying an equidistant bin width), or a vector containing the
width of each bin. The combined length of the specified bins must match the
length of the continuous part of the domain. Alternative to \code{bin_number}.
If \code{bin_number} and \code{bin_width} are both given and the two values
are not compatible, an error is returned.}

\item{bin_number}{Number of equidistant histogram bins partitioning \eqn{I}.
Alternative to \code{bin_width}. If neither parameter is specified,
\code{bin_number = 100} is used as default. If \code{bin_number} and \code{bin_width} are
both given and the two values are not compatible, an error is returned.}

\item{values_discrete}{Vector of values in \eqn{\mathcal{D}}{D} (the subset of
the domain corresponding to the discrete part of the densities). Defaults to
missing (\code{NULL}) in which case it is set to \code{c(0, 1)}. If set to
\code{FALSE}, the discrete component is considered to be empty, i.e., the
Lebesgue measure is used as reference measure (continuous special case).}

\item{weights_discrete}{Vector of weights for the Dirac measures corresponding
to \code{values_discrete}. If missing (\code{NULL}) it is set to 1 in all
components as default. Can be a scalar for equal weights for all discrete values
or a vector with specific weights for each corresponding discrete value.}

\item{domain_continuous}{An interval (i.e., a vector of length 2) specifying
\eqn{I} (the subset of the domain corresponding to the continuous part of the
densities). If missing (\code{NULL}) it is set to \code{c(0, 1)} as default. If
set to \code{FALSE}, the continuous component is considered to be empty, i.e.,
a weighted sum of dirac measures is used as reference measure (discrete special
case).}
}
\value{
The function returns an object of the class \code{histogram_count_data},
which is a \code{\link[data.table]{data.table}} with columns:
\itemize{
\item \code{counts} - For each by \code{var_vec} defined covariate combination
the observed (histogram) counts in the first column.
\item \code{weighted_counts} - If \code{sample_weights} is not \code{NULL}:
Weighted (histogram) counts for the respective bin/discrete value incorporating
the sample weights given by \code{sample_weights}.
\item name of variable given to \code{y} - Marks the mid of the respective
histogram bin (for values in \eqn{I\setminus D}) or the discrete value. If a
mid corresponds to a discrete value, the mid is shifted to the right by
\eqn{0.0001} times the minimal distance to the next interval limit OR discrete
value so that no mid is exactly corresponding to a discrete value. A warning
message is generated in this case.
\item names of all variable columns which where specified by \code{var_vec} -
These columns contain the values of the respective variables.
\item \code{group_id} - ID of each covariate combination.
\item \code{gam_weights} - Vector to be passed to argument \code{weights} in
\code{\link[mgcv]{gam}} when fitting the Poisson Model, if \code{dta} contains
sample weights, see Appendix C of Maier et al. (2023).
\item \code{gam_offset} - Negative logarithm of \code{gam_weights} to be used
as offset to the predictor of the Poisson Model, if \code{dta} contains sample
weights, see Appendix C of Maier et al. (2023).
\item \code{Delta} - Width of the histogram bin or weight of the Dirac measure
for a discrete value defined by \code{weights_discrete}. The Poisson model uses
\code{offset(log(Delta))} to add the necessary additive term in the predictor
that includes binwidths/dirac weights into the estimation.
\item \code{discrete} - Logical value indicating whether the respective \code{y}
is a discrete value in \eqn{D}.
}
Note that a \code{plot}-method for objects of class \code{histogram_count_data}
is available via \code{DensityRegression:::histogram_count_data}, however, it is
not exported, since it is not tested/documented appropriately, yet.
}
\description{
\code{data2counts} prepares data containing the individual response observations
\eqn{y_i} appropriately to be used in \code{\link[mgcv]{gam}} Poisson models
by combining all observations of the same conditional distribution (i.e., all
observations sharing identical values in all covariates) into a vector of counts
via a histogram on \eqn{I\setminus D} and counts on \eqn{D} where \eqn{I} is
the interval of the continuous domain and \eqn{D} the set of discrete values.
the discrete component of the underlying mixed (continuous/discrete)
Bayes Hilbert space \eqn{B^2(\mu) = B^2(\mathcal{Y}, \mathcal{A}, \mu)}{B^2(\mu) = B^2(Y, A, \mu)}.
We briefly summarize the approach below in the details. Please see Section 2.3
in Maier et al. (2025b) for comprehensive description.
}
\examples{
set.seed(101)

# create data where 0 and 1 are the discrete observations, values
# equal 2 are replaced below by drawing from a beta distribution

dta <- data.frame(obs_density = sample(0:2, 100, replace = TRUE,
                  prob = c(0.15, 0.1, 0.75)),
                  covariate1 = sample(c("a", "b"), 100, replace = TRUE),
                  covariate2 = sample(c("c", "d"), 100, replace = TRUE),
                  sample_weights = runif (100, 0, 2))
dta[which(dta$obs_density == 2), ]$obs_density <- rbeta(length(which(dta$obs_density == 2)),
                                                        shape1 = 3, shape2 = 3)

# Create histogram count dataset for dta using 10 equidistant
# bins and default values for continuous domain, discrete
# values and discrete weights while considering a mixed case
# of continuous and discrete domains. The following function calls are
# equivalent:

data2counts(dta, var_vec = c("covariate1", "covariate2"), y = "obs_density",
           sample_weights = "sample_weights", bin_number = 10)
data2counts(dta, var_vec = c(2, 3), y = 1, sample_weights = 4, bin_width = 0.1)

# Use the vector bin_width to define non-equidistant bins and
# specify with values_discrete and weights_discrete discrete values
# and weights besides the default (0,1) and weight 1:

data2counts(dta, var_vec = c(2, 3), y = 1, sample_weights = 4,
           bin_width = c(0.1, 0.5, 0.4), values_discrete = c(0, 1),
           weights_discrete = c(0.5, 2))

# The use of "values_discrete=FALSE" refers to histogram data in a
# purely continous setting (note that now the observations at 0 and 1 are
# counted towards the outer bins):

data2counts(dta, var_vec = c(2, 3), y = 1, sample_weights = 4, bin_width = 0.1,
           values_discrete = FALSE)

# filter data set for only observations valued in discrete domain

dta_discrete <- dta[which(dta$obs_density \%in\% c(0, 1)), ]

# The use of "domain_continuous=FALSE" refers to histogram data in a
# purely discrete setting:

data2counts(dta_discrete, var_vec = c(2, 3), y = 1, sample_weights = 4,
           bin_width = 0.1, values_discrete = c(0, 1),
           weights_discrete = c(0.5, 2), domain_continuous  = FALSE)

# use the optional argument counts to "data2counts" already preprocessed
# data and select only one of two variables for the grouping
dta_discrete <- unique(dta_discrete[, 1:3])
dta_discrete$counts <- sample(0:10, nrow(dta_discrete), replace = TRUE)

data2counts(dta_discrete, var_vec = "covariate1", y = "obs_density",
           counts = "counts", bin_width = 0.1, values_discrete = c(0, 1),
           weights_discrete = c(0.5, 2), domain_continuous  = FALSE)

}
\references{
Maier, E.-M., Fottner, A., Stoecker, A., Okhrin, Y., & Greven, S. (2025b):
Conditional density regression for individual-level data.
arXiv preprint arXiv:XXXX.XXXXX.
}
\seealso{
\code{\link{densreg}}
}
\author{
Lea Runge, Eva-Maria Maier
}
