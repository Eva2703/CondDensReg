% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dens_reg.R
\encoding{UTF-8}
\name{dens_reg}
\alias{dens_reg}
\title{Conditional density regression for individual-level data}
\usage{
dens_reg(
  dta,
  var_vec,
  density_var,
  sample_weights = NULL,
  bin_width = NULL,
  bin_number = NULL,
  values_discrete = c(0, 1),
  weights_discrete = 1,
  domain_continuous = c(0, 1),
  m_density_var = c(2, 2),
  k_density_var = 10,
  sp_density_var = NULL,
  penalty_discrete = NULL,
  group_specific_intercepts = NULL,
  linear_effects = NULL,
  flexible_effects = NULL,
  varying_coefficients = NULL,
  flexible_interaction = NULL,
  effects = FALSE,
  ...
)
}
\arguments{
\item{dta}{Data set of type \code{\link[base]{data.frame}} or
\code{\link[data.table]{data.table}} containing the observations \eqn{(y_i, x_i)}
of response and covariates as well as optional sampling weights for each
observation in the rows (\eqn{i = 1,...,N}).}

\item{var_vec}{Vector of variables in \code{dta} on which the covariate
combinations are based. (All covariates or a subset in case some covariates
are a refinement of others.) The vector can either contain the variable names
as strings or the column positions of the respective variables in \code{dta}.}

\item{density_var}{Variable in \code{dta} which corresponds to the response.
Variable name as string or numeric column position of the variable in \code{dta}.}

\item{sample_weights}{Variable in \code{dta} which contains a sample weight
for each observation. Variable name as string or numeric column position of
the variable in \code{dta}. If missing (\code{NULL}), no sample weights are
included per default.}

\item{bin_width}{Width of histogram bins partitioning \eqn{I} (the subset of
the domain corresponding to the continuous part of the densities). Can be one
scalar value (specifying an equidistant bin width), or a vector containing the
width of each bin. The combined length of the specified bins must match the
length of the continuous part of the domain. Alternative to \code{bin_number}.}

\item{bin_number}{Number of equidistant histogram bins partitioning \eqn{I}.
Alternative to \code{bin_width}. If \code{bin_number} and \code{bin_width} are
both given and the two values are not compatible, an error is returned. If
neither parameter is specified, \code{bin_number=100} is used as default.}

\item{values_discrete}{Vector of values in \eqn{\mathcal{D}}{D} (the subset of
the domain corresponding to the discrete part of the densities). Defaults to
missing (\code{NULL}) in which case it is set to \code{c(0, 1)}. If set to
\code{FALSE}, the discrete component is considered to be empty, i.e., the
Lebesgue measure is used as reference measure (continuous special case).}

\item{weights_discrete}{Vector of weights for the Dirac measures corresponding
to \code{values_discrete}. If missing (\code{NULL}) it is set to 1 in all
components as default. Can be a scalar for equal weights for all discrete values
or a vector with specific weights for each corresponding discrete value.}

\item{domain_continuous}{An interval (i.e., a vector of length 2) specifying
\eqn{I}. If missing (\code{NULL}) it is set to \code{c(0, 1)} as default. If
set to \code{FALSE}, the continuous component is considered to be empty, i.e.,
a weighted sum of dirac measures is used as reference measure (discrete special
case).}

\item{m_density_var}{Vector of two integers specifying the order of the B-spline
basis over \eqn{I} and the order of the difference penalty (like the argument
\code{m} for P-Spline smooth terms, i.e., \code{bs="ps"} in \code{\link[mgcv]{ti}},
etc.) for basis functions in \eqn{L^2(\lambda)} (before transformation to \eqn{L^2_0(\lambda)},
compare details). If missing it is set to cubic splines with second
order difference penalty, i.e., \code{m_density_var=c(2,2)}, as default.}

\item{k_density_var}{Integer specifying the number of B-spline basis functions
over \eqn{I}, i.e., the length of the vector \eqn{b_{\mathcal{Y}}{b_Y}}{b_Y}
(like the argument \code{k} for P-Spline smooth terms, i.e., \code{bs="ps"} in
\code{\link[mgcv]{ti}}, etc.) for basis functions in \eqn{L^2(\lambda)}
(before transformation to \eqn{L^2_0(\lambda)}, compare details). See
\code{\link[mgcv]{choose.k}} for more information.
If missing (\code{NULL}) it is set to 10.}

\item{sp_density_var}{Integer or vector specifying the smoothing parameter for the marginal
penalty matrix for \eqn{b_{\mathcal{Y}}{b_Y}}{b_Y} (anisotropic penalty; like
the argument \code{sp} in \code{\link[mgcv]{ti}}, etc.). If a vector is submitted, all smoothing parameters
in density direction are treated as fixed but with different values for the different partial effects. The
order of parameters within this vector is the same as the order of partial effects as arguments of \code{dens_reg} with the firtst parameter corresponding to the intercept.
It must be of the same length as the number of partial effects plus one.
In the discrete case of only discrete values and a zero \code{penalty_discrete}, the smoothing
parameter \code{sp_density_var} is set to zero in order to obtain an unpenalized
model. If missing (\code{NULL}) or a negative value is supplied, the parameter
will be estimated by \code{\link[mgcv]{gam}}. Any positive or zero value is
treated as fixed. (see \code{mgcv})}

\item{penalty_discrete}{Integer or \code{NULL} giving the order of differences
to be used for the penalty of the discrete component, with 0 corresponding to
the identity matrix as penalty matrix (analogously to m[2] for the continuous
component); Note that the order of differences must be smaller than the number
of values in the discrete component, i.e., the length of values_discrete; if
missing (\code{NULL}), in the mixed case, it is set to a zero matrix (corresponding
to no penalization), while in the discrete case, it is set to a diagonal matrix
(as in a ridge penalty). In the discrete case, please set the corresponding
argument of sp in ti() to 0 to estimate an unpenalized model.}

\item{group_specific_intercepts}{Vector of the form \code{c("cov_1","cov_2",...)}
of names of categorical variables included by \code{var_vec} for which
covariate-specific intercepts \eqn{\beta_{cov_1},\ \beta_{cov_2},\ ...} are
included in the model. If mising (\code{NULL}), no covariate-specific intercept
is included.}

\item{linear_effects}{Vector of the form \code{c("cov_1","cov_2",...)} of names
of numeric variables included by \code{var_vec} for which linear effects
\eqn{\beta_{cov_1}\cdot cov_1,\ \beta_{cov_2}\cdot cov_2,\ ...} are included
in the model. If mising (\code{NULL}), no linear is included.}

\item{flexible_effects}{List of lists of the form
\code{list(list("cov_1","basis_1", m_1,k_1,mc1,"by_1"),list(...),...)}. Each list
is adding one flexible effect of the form \eqn{f_{by}(cov)} to the model with:
\itemize{
\item \code{"cov"}: Name of a numeric variable included in \code{var_vec}.
\item \code{"basis"}: Character string specifying the type for the marginal
basis in covariate direction. See \code{mgcv::smooth.terms} for details and
full list.
\item \code{m}: Vector of two integers or \code{NULL} giving the order of the
marginal spline basis \eqn{b_j} in covariate direction and the order of its
penalty. (see \code{mgcv})
\item \code{k}: Integer or \code{NULL} giving the dimension of the marginal
basis \eqn{b_j}. See \code{mgcv::choose.k} for more information.
 \item \code{mc}: Logical indicating if the marginal in covariate direction should have centering constraints applied. By default all marginals are constrained, i.e., \code{mc=TRUE}.
 \item \code{"by"}: Optional, name of a categorical variable included in
\code{var_vec} specifying whether the flexible effect should be modeled
specifically for each level of the by-covariate. If missing or \code{NULL},
the flexible effect is not depending on the level of an additional covariate.
} If mising (\code{NULL}), no flexible effect is included.}

\item{varying_coefficients}{List of lists of the form
\code{list(list("covA_1","covB_1","basis1",m1,k1, mc1),...)}. Each list is adding
one varying coefficient of the form \eqn{ cov_A*f(cov_B)} to the
model with:
\itemize{
\item \code{"covA"}: Name of a numeric variable included in \code{var_vec}.
 \item \code{"covB"}: Name of a numeric variable included in \code{var_vec}.
\item \code{"basis"}: Character string specifying the type for the marginal
basis in covariate direction. See \code{mgcv::smooth.terms} for details and
full list.
\item \code{m}: Vector of two integers or \code{NULL} giving the order of the
marginal spline basis \eqn{b_j} in covariate direction for the smooth effect
and the order of its penalty. (see \code{mgcv})
\item \code{k}: Integer or \code{NULL} giving the dimension of the marginal
basis \eqn{b_j} for the smooth effect. See \code{mgcv::choose.k} for more
information.
}If mising (\code{NULL}), no varying coeffecient is included.
\item \code{mc}: Logical indicating if the marginal in the direction of the first covariate should have centering constraints applied. By default all marginals are constrained, i.e., \code{mc=TRUE}.}

\item{flexible_interaction}{List of lists of the form
\code{list(list(c("covA_1","covB_1",...),c("basisA_1","basisB_1",...), list(mA_1, mB_1,...), c(kA_1, kB_1,...), c(mcA_1, mcB_1,...), "by"),list(...),...)}.
Each list is specifying flexible interaction effect between at least two
continuous covariates of the form \eqn{f(cov_A,cov_B,...)} in the model with:
\itemize{
\item \code{c("covA_1","covB_1", ...)}: Vector of names of numeric variables
included in \code{var_vec}.
\item \code{c("basisA", "basisB", ...}:Vector of character strings specifying
the type for the marginal bases in covariate direction. See
\code{mgcv::smooth.terms} for details and full list.
\item\code{list(mA,mB,...)}: List containing vectors of two integers or
\code{NULL} giving the order of the marginal spline basis in direction of
\eqn{cov_A} for the smooth effect and the order of its penalty. (see \code{mgcv})
\item \code{c(kA, kB, ...)}: Vector of integers or \code{NULL} giving the
dimension of the marginal basis in direction of \eqn{cov_A} for the smooth
effect. See \code{mgcv::choose.k} for more information.
 \item \code{mc}: Logical indicating if the marginal in covariate direction should have centering constraints applied. By default all marginals are constrained, i.e., \code{mc=TRUE}.
  \item \code{"by"}: Optional, name of a categorical variable included in
\code{var_vec} specifying whether the flexible interaction effect should be modeled
specifically for each level of the by-covariate. If \code{NULL},
the flexible interaction effect is not depending on the level of an additional covariate.
}}

\item{effects}{Indicates if partial effects should be returned (\code{TRUE})
or not (\code{FALSE}).}

\item{...}{further arguments for passing on to \code{gam}}
}
\value{
The returned object is a \code{list}-object which is also an object
of the sub-class \code{dens_reg_obj} with elements:
\itemize{
\item \code{model}: \code{mgcv::gam}-object of the estimated model.
\item \code{model_matrix}: Model matrix of the model.
\item \code{theta_hat}: Estimated coeffecient vector \eqn{\hat\theta}.
\item \code{f_hat_clr}: Estimated conditional densities on clr-level
\eqn{clr(\hat f)} for every covariate combination in the order of the respective
group_id in \code{histo_data}.
\item \code{f_hat}: Estimated conditional densities on clr-level \eqn{clr(\hat f)}
for every covariate combination in the order of the respective group_id in
\code{histo_data}.
\item \code{histo_data}: \code{data.table}-object containing the histogram data
resulting from the \code{preprocess}-function with the original data \code{dta}
which is also an object of the sub-class \code{histogram_count_data}. See
\code{?preprocess} for more information.
\item \code{effects}: If \code{effects=TRUE}; List of lists. Each list gives
one estimated partial effect. Both clr- and density-level are included.
\item \code{params}: List of \code{domain_continuous, values_discrete} and
\code{bin_number}.
\item \code{predicted_effects}: List of lists (\code{group_specific_intercepts,
flexible effects, linear_effects, varying_coefficient, flexible_interaction})
collecting all modeled partial effects as specified in the function's parameters.
\item \code{ID_covCombi}: Data frame which gives an overview over the assignment
of the unique covariate combinations to the group IDs.
}
}
\description{
This function implements the approach by Maier et al. (2023) for fitting
structured additive regression models with densities in a mixed (continuous/
discrete) Bayes Hilbert space
\eqn{B^2(\mu) = B^2(\mathcal{Y}, \mathcal{A}, \mu)}{B^2(\mu) = B^2(Y, A, \mu)}
as response given scalar covariates \eqn{x_i},
based on observations \eqn{y_i} from the conditional distributions given
\eqn{x_i}, via a (penalized) maximum likelihood approach. The (penalized)
log-likelihood function is approximated via the (penalized) log-likelihood of
an appropriate poisson regression model, which is then fitted using
\code{mgcv}'s \code{\link[mgcv]{gam}} with a new smooth for mixed densities.
We briefly summarize the approach below in the details.
% to enable proper description of the function.
Please see Maier et al. (2023) for comprehensive discussion.
}
\details{
The goal of \code{dens_reg} is to estimate the densities \eqn{f_{x_i}} of
conditional distributions of random variables \eqn{Y_i | x_i} from independent
observations \eqn{(y_i, x_i)}, where \eqn{y_i} are realizations of \eqn{Y_i | x_i},
and \eqn{x_i} is a vector of covariate observations, \eqn{i = 1,...,N}. The
densities are considered as elements of a mixed Bayes Hilbert space
\eqn{B^2(\mu) = B^2(\mathcal{Y}, \mathcal{A}, \mu)}{B^2(\mu) = B^2(Y, A, \mu)}
(including continuous and discrete ones as special cases). The subset of the
domain \eqn{\mathcal{Y}}{Y} corresponding to the continuous part of the densities
is denoted with \eqn{I}, the one corresponding to the discrete part with
\eqn{\mathcal{D}}{D}. The densities are modeled via a structured additive
regression model
\deqn{f_{x_i} = \bigoplus_{j=1}^J h_j (x_i)}
with partial effects \eqn{h_j (x_i) \in B^2(\mu)} depending on no, one, or
several covariates \eqn{x_i}. Each partial effect is represented using a
tensor product basis, consisting of an appropriate vector of basis functions
\eqn{b_{\mathcal{Y}}{b_Y}}{b_Y} in \eqn{B^2(\mu)} over the domain of
\eqn{B^2(\mu)}, and a vector of basis functions \eqn{b_{\mathcal{X}, j}}{b_{X, j}}
over the respective covariates. The basis functions \eqn{b_{\mathcal{Y}}}{b_Y}
are obtained by transforming a P-spline basis from \eqn{L^2(\mu)}
to
\eqn{L^2_0(\mu) := \{ f \in L^2(\mu) ~|~ \int_{\mathcal{T}} f \, \mathrm{d}\mu = 0\}}{L^2_0(\mu) := {f \in L^2(\mu) | \int_T f d\mu = 0}}
and then applying the inverse centered log-ratio (clr) transformation (the
clr transformation is an isometric isomorphism, allowing to consider densities
in \eqn{B^2(\mu)} equivalently in \eqn{L^2_0(\mu)}). See appendix D of Maier
et al. (2021) for details on the transformation from \eqn{L^2(\mu)} to
\eqn{L^2_0(\mu)}. The choice of \eqn{b_{\mathcal{X}, j}}{b_{X, j}} determines
the type of the partial effect (e.g., linear or smooth for a continuous covariate).
Penalization is also possible.
The resulting log-likelihood is then approximated by the log-likelihood of a
corresponding multinomial model, which can equivalently be estimated by a
poisson model. The data for these models is obtained from the original
observations \eqn{y_1,...,y_N} by combining all observations of the same
conditional distribution into a vector of counts via a histogram on the
continuous part of the domain of the densities and counts on the discrete
part of the domain. For details, see Maier et al. (2023).
\code{dens_reg} performs the transformation into appropriate count data and
estimates the corresponding poisson model. Furthermore, the resulting densities on
pdf- and clr-level as well as the estimated partial effects on both levels are
calculated.
}
\examples{
\donttest{# for further information on the parameters of the preprocessing step
# see ?preprocess

library(dplyr)

# create data (mixed)

dta <- data.frame(obs_density = sample(0:2, 150, replace = TRUE, prob = c(0.15, 0.1, 0.75)),
                  covariate1 = sample(c("a", "b", "c"), 150, replace = TRUE),
                  covariate2 = sample(c("c", "d"), 150, replace = TRUE),
                  covariate3 = rep(rnorm(n = 15), 10),
                  covariate4 = rep(rnorm(n = 10), 15),
                  covariate5=rep(rnorm(n = 10), 15), sample_weights = runif(150, 0, 2))
dta[which(dta$obs_density == 2),]$obs_density <-rbeta(length(which(dta$obs_density == 2)), shape1 = 3, shape2 = 3)
dta$covariate1 <- ordered(dta$covariate1)
dta$covariate2 <- ordered(dta$covariate2)

# create discrete data

dta_dis <- data.frame(obs_density = sample(0:2, 150, replace = TRUE, prob = c(0.25, 0.45,0.3)),
                      covariate1 = sample(c("a", "b", "c"), 150, replace = TRUE),
                      covariate2 = sample(c("c", "d"), 150, replace = TRUE),
                      covariate3 = rep(rnorm(n = 15), 10),
                      covariate4 = rep(rnorm(n = 10), 15),
                      covariate5=rep(rnorm(n = 10), 15),
                      sample_weights = runif(150, 0, 2))
dta_dis$covariate1 <- ordered(dta_dis$covariate1)
dta_dis$covariate2 <- ordered(dta_dis$covariate2)

# examples for different partial effects

## group specific intercepts
group_specific_intercepts <- c("covariate1", "covariate2")
## linear effects
linear_effects <- c("covariate4")
## flexible effects
flexible_effects <-list(list("covariate3", "ps", c(2, 2), 4, NULL,NULL), list("covariate3", "ps", c(2, 2), 4,FALSE, "covariate1"))
## varying coefficient
fvc <-list(list("covariate3", "covariate4", "ps", c(2, 2) , 4, TRUE))
## flexible interaction
flex_inter <-list(list(c("covariate3", "covariate4","covariate5"), c("ps", "ps","ps"),list( c(2, 2), c(2, 2), c(2, 2)),c( 4, 4,5), list(TRUE, FALSE, TRUE), NULL))

# fit models (warning: calculation may take a few minutes)

## fit model for the mixed case with group specific intercepts and linear effects
### use fixed smoothing parameters in density direction and calculate also the partial effects

m_mixed <- dens_reg(dta = dta, var_vec = c(2:6), density_var = 1, m_density_var = c(2, 2),
  k_density_var = 4, group_specific_intercepts = group_specific_intercepts,
  linear_effects = linear_effects, effects = TRUE, sp_density_var=c(1,3,5,0.5))

## fit model for the discrete case with flexible effects and flexible interaction
### do not calculate effects

m_dis <- dens_reg(
  dta = dta_dis, var_vec = c(2:6), density_var = 1, values_discrete = c(0, 1,2),
  weights_discrete = c(1,1,1), domain_continuous = FALSE, m_density_var = c(2, 2),
  k_density_var = 4, group_specific_intercepts = group_specific_intercepts,
  flexible_effects = flexible_effects, flexible_interaction = flex_inter, effects = FALSE)

# fit model for the continuous case with a functional varying coeffecient

m_cont <- dens_reg(dta = dta\%>\%filter(obs_density!=0&obs_density!=1),
  var_vec = c(2:6), density_var = 1, values_discrete = FALSE, m_density_var = c(2, 2),
  k_density_var = 12, varying_coefficients = fvc, effects = TRUE)


}
}
\references{
Maier, E. M., Fottner, A., Stöcker, A., Okhrin, Y., & Greven, S. (2023). Conditional density regression for individual-level data.
}
